#!/usr/bin/env python
# -*- coding: utf-8 -*-
# -*- offset: 2 spaces -*-

"""
Copyright (c) 2013 Ponomarev Dmitry <demdxx@gmail.com>

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in the
Software without restriction, including without limitation the rights to use, copy,
modify, merge, publish, distribute, sublicense, and/or sell copies of the Software,
and to permit persons to whom the Software is furnished to do so, subject to the
following conditions:

The above copyright notice and this permission notice shall be included in all copies
or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
"""

import os, sys, subprocess
from urlparse import urlparse

try:
  import json
except ImportError:
  import simplejson as json

__version__ = '1.0.0alpha'
__autor__ = 'Dmitry Ponomarev <demdxx@gmail.com>'
__year__ = '2014'
__license__ = 'MIT'


GOPATHS = [
  '~/bin/go'
 ,'~/go/bin/go'
 ,'/usr/local/bin/go'
 ,'/usr/local/go/bin/go'
 ,'/usr/local/opt/go/bin/go'
 ,'/usr/bin/go'
]


def load_config(filepath):
  # load file
  with open(filepath, 'rb') as file:
    data = ''.join([row for row in file])
    # Try parse json project
    try:
      jdata = json.loads(data)
    except Exception, e: # else eval as python
      jdata = eval(data)
    return jdata
  return None

def save_config(filepath, conf):
  with open(filepath, 'w+') as file:
    file.write(json.dumps(conf))

def key_as_array(dictionary, keys):
  if not isinstance(keys, (list, tuple)):
    keys = [keys]
  for k in keys:
    if dictionary.has_key(k):
      return dictionary[k] \
        if isinstance(dictionary[k], (list, tuple)) else [dictionary[k]]
  return None

def out(str):
  print(str)

def find_first_parent_file(dir, filenames=None):
  """
  Find solution ile, recursion up to tree
  @param current dir path
  @param filenames string or array name variants
  @return (projectdir, absfilepath)
  """
  if not dir or not filenames:
    return None, None

  if os.path.isfile(dir):
    return os.path.dirname(dir), os.path.realpath(dir)

  if isinstance(filenames, basestring):
    filenames = [filenames]

  for fname in filenames:
    pathname = '%s/%s' % (dir, fname)
    if os.path.isfile(pathname) or os.path.islink(pathname):
      return dir, os.path.realpath(pathname)

  if len(dir)<1 or dir=='/':
    return None, None

  return find_first_parent_file(dir=os.path.dirname(dir), filenames=filenames)

###############################################################################
### Go Project Config
###############################################################################

class Config:

  def __init__(self, confpath=None):
    self.inited = False
    self.APPNAME = None
    self.SOLUTIONDIR = None
    self.DIRNAME = None
    self.CONFIGPATH = None
    self.DEPS = []
    self.BUILD = []
    self.ENVIRON = {}
    self.GO = self.__class__.__go()
    self.CONF = {}
    if confpath is not None:
      self.load(confpath)

  def load(self, confpath):
    if confpath is None or not os.path.isfile(confpath):
      return self

    jdata = load_config(confpath)

    self.CONF = jdata
    self.DEPS = self.__class__.__prepare_apps(key_as_array(jdata, ['deps', 'dependings']))
    self.BUILD = jdata.get('build', None)

    self.CONFIGPATH = confpath
    self.DIRNAME = os.path.dirname(confpath)
    self.SOLUTIONDIR = self.__class__.solutiondir(self.DIRNAME)
    self.APPNAME = self.DIRNAME[len(self.SOLUTIONDIR)+5:]

    self.ENVIRON['GOOS'] = jdata.get('os', None)
    self.ENVIRON['GOARCH'] = jdata.get('arch', None)
    self.ENVIRON['GOARM'] = jdata.get('arm', None)

    self.APP = self.CONF.copy()
    self.APP.pop('deps', None)
    self.APP.pop('dependings', None)
    self.APP.pop('env', None)

    # Custom enviroment
    env = jdata.get('env', None)
    if env and isinstance(env, dict):
      self.ENVIRON.update(env)
    else:
      self.ENVIRON['ENV'] = env # Custom environ settings

    self.inited = True

    return self

  # Set application environ
  def set_env(self, appname=None):
    if not self.inited:
      return False

    # Search go path dirs
    os.environ['GOPATH'] = self.SOLUTIONDIR

    # Add project path
    os.environ['PATH'] = '%s:%s/bin' % (os.environ['PATH'], self.SOLUTIONDIR)

    # Init enviroments
    env = self.environ(appname)
    if env:
      for k, v in env.items():
        if v and k != 'ENV':
          os.environ[k] = v

      # execute system commands
      if 'ENV' in env and env['ENV']:
        for s in env['ENV']:
          os.system(s)

    # Set build architecture
    arch = self.arch()
    if arch:
      os.environ['GOARCH'] = arch

    return True

  #############################################################################
  ### Getters/Setters
  #############################################################################

  def go(self):
    if not self.GO:
      self.GO = self.gopath()
    return self.GO

  def gopath(self):
    if not hasattr(self, 'GOPATH'):
      self.GOPATH = self.SOLUTIONDIR
    return self.GOPATH

  def deps(self):
    return self.DEPS

  def apps(self):
    if not hasattr(self, 'APPS') or not self.APPS:
      self.APPS = self.__class__.__prepare_apps({self.APPNAME: self.APP})
    apps = self.APPS.copy()
    apps.update(self.DEPS)
    return apps

  def arch(self):
    return self.ENVIRON.get('GOARCH', 'arm' if self.ENVIRON.get('GOARM', None) else None)

  def environ(self, appname=None):
    if appname is None:
      return self.ENVIRON
    apps = self.deps()
    if appname in apps:
      appenv = apps[appname].get('env', None)
      if appenv:
        env = self.ENVIRON.copy()
        env.update(appenv)
        return env
    return self.ENVIRON

  #############################################################################
  ### Helpers
  #############################################################################

  def prepare_path(self, path):
    return path.format(projectpath=self.DIRNAME)

  @staticmethod
  def solutiondir(path):
    dirpath, _conf = find_first_parent_file(dir=path, filenames=['.gosolution'])
    return dirpath

  def __gopath(self):
    GOPATH = self.DIRNAME
    if 'paths' in self.CONF:
      if isinstance(self.CONF['paths'], basestring):
        self.CONF['paths'] = [self.CONF['paths']]
      if len(self.CONF['paths']) > 0:
        GOPATH += ':' + ':'.join(self.CONF['paths'])
    return self.prepare_path(GOPATH)

  @classmethod
  def __go(self):
    # Search go path
    GO = subprocess.Popen("which go", shell=True, stdout=subprocess.PIPE).communicate()[0].strip()
    if not GO:
      for _go in GOPATHS:
        if os.path.isfile(_go) or os.path.islink(_go):
          GO = _go
          break
    if not GO:
      GO = 'go'
    return GO

  @staticmethod
  def __prepare_apps(apps):
    if not apps or isinstance(apps, dict):
      return apps
    data = {}
    for v in apps:
      if isinstance(v, basestring):
        data[v] = {}
      elif isinstance(v, dict):
        data.update(v)
    return data


###############################################################################
### Go Project Manager
###############################################################################

class Project:

  PROJECT_FILE = """{
  "project": "{projectname}",
  "version": "0.0.1",
  # "os": None, # Default
  # "arch": None, # Default
  # "arm": None, # Default
  "deps": [
    # ...
  ],
  # "deps": {
  #   # "github.com/robfig/revel": {
  #   #   "build": "{go} build -o revel {app}/revel",
  #   # },
  # },

  # @TODO: HOOKS
  # "hooks": {"command": {"before": ["script/path", ...]}, "after": ["script/path", ...]},
}
"""

  def __init__(self, config):
    if isinstance(config, Config):
      self.config = config
    elif not config.endswith('.goproj'):
      self.config = Config('%s/.goproj' % config)
    else:
      self.config = Config(config)

  @classmethod
  def init(self, solutionpath, projdir, projectname):
    if not projectname or  len(projectname)<1:
      out('Enter project name')
      return None

    projectpath = "%s/%s" % (solutionpath, projdir)
    config_path = "%s/.goproj" % projectpath
    goproj = open(config_path, "w+")
    # goproj.write(self.PROJECT_FILE.format(projectname=projectname, solutionpath=solutionpath, projectpath=projectpath))
    repls = {'{projectname}': projectname, '{solutionpath}': solutionpath, '{projectpath}': projectpath}
    goproj.write(reduce(lambda a, kv: a.replace(*kv), repls.iteritems(), self.PROJECT_FILE))
    goproj.close()

    return self(config_path)

  #############################################################################
  ### Commands
  #############################################################################

  def exect(self, command, args=None):
    """
    Run simple command
    @param command
    @param args
    """
    self.set_env()
    cmd = '%s %s %s' % (self.config.go(), command, ' '.join(args or []))
    out(cmd)
    os.system(cmd)

  def execute(self, command, apps, args=None, custom_only=False, dependencies=False):
    """
    Run the command separately for each dependency
    """
    self.set_env()

    if not args:
      args = []

    lapps = self.config.deps() if dependencies else self.config.apps()

    if not lapps or len(lapps) < 1:
      return self

    if apps and len(apps) > 0:
      for app in apps:
        cmd = None
        if app in lapps:
          params = lapps[app]
          if command in params:
            s_cmd = params[command]
            if s_cmd:
              cmd = s_cmd.format(go=self.config.go(), cmd=command, app=app)
          elif not custom_only:
            cmd = '%s %s %s %s' % (self.config.go(), command, ' '.join(args), app)
        else:
          cmd = '%s %s %s %s' % (self.config.go(), command, ' '.join(args), app)
        if cmd:
          out(cmd)
          os.system(cmd)
    else:
      for app, params in lapps.items():
        cmd = None
        if params and command in params:
          s_cmd = params[command]
          if s_cmd:
            cmd = s_cmd.format(go=self.config.go(), cmd=command, app=app)
        elif not custom_only:
          cmd = '%s %s %s %s' % (self.config.go(), command, ' '.join(args), app)
        if cmd:
          out(cmd)
          os.system(cmd)
    return self

  def get(self, apps=None, args=None):
    return self.execute('get', args, args, dependencies=True)

  def build(self, apps, args=None):
    if not args or len(args) < 1:
      args = self.config.BUILD
    return self.execute('build', apps, args)

  def install(self, apps=None, args=None):
    return self.execute('install', apps, args, dependencies=True)

  def clean(self, args=None):
    return self.exect('clean', args)

  def run(self, apps=None, args=None):
    return self.execute('run', apps, args, custom_only=True)

  def fmt(self, apps=None, args=None):
    return self.execute('fmt', apps, args)

  def fix(self, apps=None, args=None):
    return self.execute('fix', apps, args)

  def vet(self, apps=None, args=None):
    return self.execute('vet', apps, args)

  def doc(self, apps=None, args=None):
    return self.execute('doc', apps, args)

  def tool(self, args=None):
    return self.exect('tool', args)

  def test(self, apps, flags=None):
    return self.execute('test', apps, flags if flags and len(flags) > 0 else ['-v'])

  def print_deps(self):
    deps = self.config.deps()
    if deps and len(deps)>0:
      for dep in deps:
        out(dep)
    else:
      out('No dependencies')

  def print_apps(self):
    apps = self.config.apps()
    if apps and len(apps)>0:
      for app in apps:
        out(app)
    else:
      out('No applications')

  def print_env(self):
    self.config.set_env()

    out("PATH=%s" % os.environ['PATH'])
    out("GO=%s" % self.config.go())
    out("GOPATH=%s" % os.environ['GOPATH'])

    for k, v in self.config.environ().items():
      if 'ENV' == k:
        if isinstance(v, dict):
          for k2, v2 in v.items():
            if v2:
              out("export %s=%s" % (k2, v2))
        elif v:
          for v2 in v:
            if v2:
              out(v2)
      elif v:
        out("export %s=%s" % (k, v))

  def print_go_path(self):
    out(self.config.go())

  #############################################################################
  ### Helpers
  #############################################################################

  def set_env(self, app=None):
    if not self.config.set_env(app):
      out("I can't initialize the environment")
      exit(-1)

  @staticmethod
  def __get_app(key, apps):
    if not key or not apps:
      return None
    if key in apps:
      return apps[key]
    for k in apps:
      if len(k) < len(key) and k == key[0:len(k)]:
        return key[len(k):], k, apps[key]
    return None


###############################################################################
### Solution config
###############################################################################
class Solution:

  SOLUTION_STRUCTURE = [
    'bin',
    'src',
    'pkg'
  ]

  SOLUTION_SOURCE_DIR = 'src'

  def __init__(self, dirname):
    dirname, filepath = self.__find_solution_file(dirname)
    if dirname is None:
      self.valid = False
    else:
      self.dirname = dirname.replace("//", "/")
      self.filepath = filepath
      self.apps = load_config(filepath)
      self.valid = True

  @classmethod
  def init(self, dirpath, url=None, projname=None):
    for d in self.SOLUTION_STRUCTURE:
      directory = '%s/%s' % (dirpath, d)
      if not os.path.exists(directory):
        os.makedirs(directory)

    solution_path = "%s/.gosolution" % dirpath
    if not os.path.exists(solution_path):
      save_config(solution_path, {})

    sol = self(solution_path)

    if isinstance(url, basestring) and len(url) > 0:
      sol.init_project_by_url(url=url, projname=projname)
    elif isinstance(projname, basestring) and len(projname) > 0:
      sol.init_project(dirname=projname, conf=None)

    return sol

  def init_project(self, dirname, conf=None):
    if not self.valid:
      return False
    dirname = dirname.replace("//", "/")
    path = '%s/%s' % (self.__class__.SOLUTION_SOURCE_DIR, dirname)
    full_path = '%s/%s' % (self.dirname, path)
    if conf is None:
      conf = {}
    if not os.path.exists('%s/.goproj' % full_path):
      if not os.path.exists(full_path):
        os.makedirs(full_path)
      if conf is None or not (conf.has_key('hg') or conf.has_key('git')):
        Project.init(solutionpath=self.dirname, projdir=path, projectname=dirname)
      elif 'hg' in conf:
        com = 'hg clone "%s" "%s"' % (conf['hg'], full_path)
        out(com)
        os.system(com)
      else: # git in conf
        com = 'git clone "%s" "%s"' % (conf['git'], full_path)
        out(com)
        os.system(com)
      if not os.path.exists('%s/.goproj' % full_path):
        return False
      self.apps[dirname] = conf
      save_config(self.filepath, self.apps)
    return True

  def init_project_by_url(self, url, projname):
    if not self.valid:
      return False
    u = urlparse(url)
    conf = {}
    # Prepare project dir name
    if not projname or len(projname) < 1:
      domain = u.netloc.split('@')[-1].split(':')[0]
      projname = '%s/%s' % (domain, u.path)
      if projname.endswith('.git'):
        projname = projname[:-4]
      elif projname.endswith('.hg'):
        projname = projname[:-3]
    # configure url
    if u.scheme == 'hg':
      conf['hg'] = 'https://%s/%s?%s' % (u.netloc, u.path, u.query)
    if u.scheme in ['http', 'https']:
      if u.path.endswith('.hg'):
        conf['hg'] = url
      else:
        conf['git'] = url
    elif u.scheme == 'git':
      conf['git'] = 'https://%s/%s?%s' % (u.netloc, u.path, u.query)
    # Init project
    return self.init_project(projname, conf)

  #############################################################################
  ### Getters/Setters
  #############################################################################

  @property
  def projects(self):
    if hasattr(self, 'project_list') and self.project_list:
      return self.project_list
    self.project_list = {}
    for app in self.apps:
      self.project_list[app] = Project('%s/%s/%s' % (self.dirname, self.__class__.SOLUTION_SOURCE_DIR, app))
    return self.project_list

  #############################################################################
  ### Commands
  #############################################################################

  def get(self, apps=None, args=None):
    for p in self.projects.values():
      p.get(apps, args)
    return self

  def build(self, apps, args=None):
    for p in self.projects.values():
      p.build(apps, args)
    return self

  def install(self, apps=None, args=None):
    for p in self.projects.values():
      p.install(apps, args)
    return self

  def clean(self, args=None):
    for p in self.projects.values():
      p.clean(args)
    return self

  def run(self, apps=None, args=None):
    for p in self.projects.values():
      p.run(apps, args)
    return self

  def fmt(self, apps=None, args=None):
    for p in self.projects.values():
      p.fmt(apps, args)
    return self

  def fix(self, apps=None, args=None):
    for p in self.projects.values():
      p.fix(apps, args)
    return self

  def vet(self, apps=None, args=None):
    for p in self.projects.values():
      p.vet(apps, args)
    return self

  def doc(self, apps=None, args=None):
    for p in self.projects.values():
      p.doc(apps, args)
    return self

  def tool(self, args=None):
    for p in self.projects.values():
      p.tool(args)
    return self

  def test(self, apps, flags=None):
    for p in self.projects.values():
      p.test(apps, flags)
    return self

  def print_deps(self):
    for p in self.projects.values():
      p.print_deps()
    return self

  def print_apps(self):
    for p in self.projects.values():
      p.print_apps()
    return self

  def print_env(self):
    next(self.projects.itervalues()).print_env()

  def print_go_path(self):
    next(self.projects.itervalues()).print_go_path()

  #############################################################################
  ### Helpers
  #############################################################################

  @classmethod
  def __find_solution_file(klass, dir, filenames=None):
    if not dir:
      return None, None

    if not filenames:
      filenames = ['.gosolution']
    elif isinstance(filenames, basestring):
      filenames = [filenames]

    return find_first_parent_file(dir=dir, filenames=filenames)

###############################################################################
### Main Console Programm
###############################################################################
class Go:
  """
  Program to execute commands from the console
  """

  HELP = {
    'init'    : 'create project structure. goptoj init [folder] <name>',
    'deps'    : 'list of dependencies',
    'list'    : 'list packages',
    'build'   : 'compile packages and dependencies',
    'clean'   : 'remove object files',
    'doc'     : 'run godoc on package sources',
    'fix'     : 'run go tool fix on packages',
    'fmt'     : 'run gofmt on package sources',
    'get'     : 'download and install packages and dependencies',
    'install' : 'compile and install packages and dependencies',
    'run'     : 'compile and run Go program',
    'test'    : 'test packages',
    'tool'    : 'run specified go tool',
    'vet'     : 'run go tool vet on packages',
    'version' : 'show goproj version',
    'info'    : 'print enviroment info',
    'go'      : 'return path for go',
    'help'    : 'show help or help [command]'
  }

  @classmethod
  def solution(self):
    return Solution(os.getcwd())

  @classmethod
  def run(self, action, args):
    if 'init' == action:
      subdir = args[0] if len(args) >= 1 else None
      url = args[0] if len(args) >= 1 else None
      projname = args[1] if len(args) > 1 else None
      # Project.init(dirpath=os.getcwd(), projectname=projname, subdir=subdir)
      Solution.init(dirpath=os.getcwd(), url=url, projname=projname)
    else:
      words, flags = self.command_line_prepare(args)
      if 'deps' == action:
        self.solution().print_deps()
      elif 'list' == action:
        self.solution().print_apps()
      elif action == 'get':
        self.solution().get(words, flags)
      elif 'build' == action:
        self.solution().build(words, flags)
      elif 'install' == action:
        self.solution().install(words, flags)
      elif 'clean' == action:
        self.solution().clean(args)
      elif 'run' == action:
        self.solution().run(words, flags)
      elif 'fmt' == action:
        self.solution().fmt(words, flags)
      elif 'fix' == action:
        self.solution().fix(words, flags)
      elif 'test' == action:
        self.solution().test(words, flags)
      elif 'vet' == action:
        self.solution().vet(words, flags)
      elif 'doc' == action:
        self.solution().doc(words, flags)
      elif 'tool' == action:
        self.solution().tool(args)
      elif 'info' == action:
        self.solution().print_env()
      elif 'go' == action:
        self.solution().print_go_path()
      elif 'version' == action:
        out('goproj version %s %s %s' % (__version__, __autor__, __year__))
      elif 'help' == action:
        if len(args)>0:
          self.solution().help('help', conf, args)
        else:
          self.print_help()
      else:
        self.print_help()

  @classmethod
  def print_help(self):
    out('GOPROJ v%s %s %s' % (__version__, __autor__, __year__))
    out("======================================================")
    for k, v in self.HELP.items():
      out('{0:10s} {1:s}'.format(k, v))
    out('')

  #############################################################################
  ### Helpers
  #############################################################################

  @staticmethod
  def command_line_prepare(args):
    _flags = []
    _strings = []
    if not args:
      return _strings, _flags
    add_next = False
    for a in args:
      if add_next:
        _flags.append(a)
        add_next = False
      elif a[:2] == '--':
        add_next = True
        _flags.append(a)
      elif a[0] == '-':
        _flags.append(a)
      else:
        _strings.append(a)
    return _strings, _flags


###############################################################################
### Main
###############################################################################
if __name__ == "__main__":
  args = sys.argv[1:]
  action = args[0] if len(args)>0 else ''
  Go.run(action, args[1:] if len(args)>1 else [])
